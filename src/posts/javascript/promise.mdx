# promise

## API

Promise实例具有三种状态

- pending 异步操作未完成
- fulfilled 异步操作成功
- rejected 异步操作失败

这三种状态的变化途径只有两种

- 从pending 到 fulfilled
- 从pending 到 rejected

函数：

- `Promise.resolve`：返回一个 fulfilled 的 Promise 对象
- `Promise.reject`：返回一个 rejected 的 Promise 对象
- `Promise.then`：制定 promise 执行结果的函数，包含 fulfilled 和 rejected
- `Promise.all`：并行执行多个 promise，并等待所有 promise 都准备就绪
- `Promise.allSettled`：如果任意的 promise reject，则 `Promise.all` 整个将会 reject
- `Promise.race`：只等待第一个 settled 的 promise 并获取其结果（或 error）。
- `Promise.any`与 `Promise.race` 类似，区别在于 `Promise.any` 只等待第一个 fulfilled 的 promise，并将这个 fulfilled 的 promise 返回。

## 问题

### **Promise 会吃掉错误**

在浏览器中执行以下代码：

```tsx
const doAsyncThing = function () {
  return new Promise(function (resolve, reject) {
    // 下面一行会报错，因为x没有声明
    throw new Error("test error");
  });
};

doAsyncThing()

setTimeout(() => {
  console.log(123);
}, 2000);
// Uncaught (in promise) Error: test error
// 123
```

上面代码中，`someAsyncThing()`函数产生的 Promise 对象，内部有语法错误，浏览器会打印出错误提示`ReferenceError: x is not defined`，但是不会退出进程、终止脚本执行，2 秒之后还是会输出`123`。

阮一峰的 es6 书籍中说：

> 跟传统的`try/catch`代码块不同的是，如果没有使用`catch()`方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。
> 

*抛出的错误不会传递到外层代码* 这句话换成人话就是：设置 `window.onerror` 捕获 `error` ，是捕获不到 promise 内部抛出的错误，看以下代码，`onerror` 里的打印并未执行（即捕获不到 promise 内部 throw 的 `error`：

```jsx
window.onerror = function () {   // 我们添加了 window 的 onerror 处理函数
    console.log('window err')
} 

promise = new Promise(function(resolve, reject) {
    throw new Error('test');
});
promise.then(function(value) { console.log(value) })   

// 控制台输出:
// Uncaught (in promise) Error: test
```

如果加了 catch，是能捕获到内部的错误

```jsx
window.onerror = function () {
    console.log('window err')
} 

var promise = new Promise(function(resolve, reject) {
    throw new Error('test');
});

promise
    .then(function(value) { console.log(value) })
    .catch((err) => console.log('promise catch err'))

// 控制台输出:
// promise catch err
```

有些博客说吃掉错误是指不影响全局代码的执行，这是误解，**实际应是 promise 外部捕获不到内部抛出的错误。**

在浏览器中，确实不会影响全局代码的执行。
但是在 nodeJS 中，会影响全局代码的执行，直接 exit 0 了，必须设置 catch，才会继续执行。

```jsx
const doAsyncThing = function () {
  return new Promise(function (resolve, reject) {
    // 下面一行会报错，因为x没有声明
    throw new Error("test error");
  });
};

doAsyncThing();

setTimeout(() => {
  console.log(123);
}, 2000);

// 控制台输出:
// Error: test error
```

链式调用 promise 时，写上 catch 是一个好习惯。

### 异步的传染性

有两种说法，均出现在用 `aysnc` 和 `await` 方式使用 promise 时，即异步转同步的写法：

- 如果同时执行多个返回 promise 的函数，并且之间存在依赖，即上一个 promise 的结果是下一个 promise 的参数，那么所有 promise 的封装函数必须都写上 `async` 和 `await`
- 如果一个底层函数使用了 async，那么所有基于它的所有调用链都必须使用 await 获取结果，或者使用 .then()。

## 手写 promise

```jsx
const PENDING = "PENDING";
const FULFILLED = "FULFILLED";
const REJECTED = "REJECTED";

class MyPromsie {
  constructor(executor) {
    this.status = PENDING;
    this.value = undefined;
    this.reason = undefined;
    this.onResolvedCallbacks = [];
    this.onRejectedCallbacks = [];

    let resolve = (value) => {
      if (this.status == PENDING) {
        this.status = FULFILLED;
        this.value = value;
        this.onResolvedCallbacks.forEach((fn) => fn());
      }
    };

    let reject = (reason) => {
      if (this.status == PENDING) {
        this.status = REJECTED;
        this.reason = reason;
        this.onRejectedCallbacks.forEach((fn) => fn());
      }
    };

    try {
      executor(resolve, reject);
    } catch (e) {
      reject(error);
    }
  }

  then(onFullfilled, onRejected) {
    if (this.status == FULFILLED) {
      onFullfilled(this.value);
    }

    if (this.status == REJECTED) {
      onRejected(this.reason);
    }

    if (this.status === PENDING) {
      // 如果promise的状态是 pending，需要将 onFulfilled 和 onRejected 函数存放起来，等待状态确定后，再依次将对应的函数执行
      this.onResolvedCallbacks.push(() => {
        onFullfilled(this.value);
      });

      // 如果promise的状态是 pending，需要将 onFulfilled 和 onRejected 函数存放起来，等待状态确定后，再依次将对应的函数执行
      this.onRejectedCallbacks.push(() => {
        onRejected(this.reason);
      });
    }
  }
}

let p1 = new MyPromsie((res) => {
  setTimeout(() => {
    res("ok");
  }, 1000);
});
p1.then((res) => {
  console.log("then", res);
});
```

## 应用场景

1. 在访问接口的时候，需要有过渡动画，实现一个需求，如果接口在半秒内响应完毕，只显示半秒的过渡动画，若超过，则等到接口响应完毕再关闭动画。

```jsx
function API() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve();
    }, 5000);
  });
}

let loadTime = () => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve();
    }, 500);
  });
};

function wrapFun(request) {
  return Promise.allSettled([loadTime(), request()]);
}

wrapFun(API).then(() => {
  console.log("ok");
});
```

1. 实现最多 5 个接口并行请求。

```jsx
function API() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve("ok");
    }, 1000);
  });
}

let i = 0;
let arr = new Array(20).fill(0);

function limitLoad(requests, limit) {
  const promises = requests.slice(0, limit).map((item, index) => {
    return API().then(() => index);
  });

  return requests
    .reduce((pre, cur, index) => {
      if (index < limit) {
        return pre;
      }
      return pre
        .then(() => Promise.race(promises))
        .catch((err) => console.error(err))
        .then((idx) => {
          console.log(
            `第${idx}个位置的请求结束，将第${index}个接口放入,共${requests.length}个请求`
          );
          promises[idx] = pro().then(() => idx);
        });
    }, Promise.resolve())
    .then(() => Promise.all(promises));
}

limitLoad(arr, 5);
```

## 参考资料
[Promise API](https://zh.javascript.info/promise-api)