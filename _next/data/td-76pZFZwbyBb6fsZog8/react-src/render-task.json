{"pageProps":{"toc":[{"text":"渲染任务的执行","hash":"#渲染任务的执行","depth":1},{"text":"源码分析","hash":"#源码分析","depth":2},{"text":"核心逻辑","hash":"#核心逻辑","depth":2}],"code":"var Component=(()=>{var h=Object.create;var s=Object.defineProperty;var u=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var g=Object.getPrototypeOf,k=Object.prototype.hasOwnProperty;var f=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),m=(r,e)=>{for(var t in e)s(r,t,{get:e[t],enumerable:!0})},i=(r,e,t,a)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of p(e))!k.call(r,o)&&o!==t&&s(r,o,{get:()=>e[o],enumerable:!(a=u(e,o))||a.enumerable});return r};var w=(r,e,t)=>(t=r!=null?h(g(r)):{},i(e||!r||!r.__esModule?s(t,\"default\",{value:r,enumerable:!0}):t,r)),b=r=>i(s({},\"__esModule\",{value:!0}),r);var l=f((I,d)=>{d.exports=_jsx_runtime});var x={};m(x,{default:()=>P});var n=w(l());function c(r){let e=Object.assign({h1:\"h1\",p:\"p\",code:\"code\",h2:\"h2\",pre:\"pre\"},r.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h1,{hash:\"\\u6E32\\u67D3\\u4EFB\\u52A1\\u7684\\u6267\\u884C\",children:\"\\u6E32\\u67D3\\u4EFB\\u52A1\\u7684\\u6267\\u884C\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"\\u521D\\u6B21\\u6E32\\u67D3\\u548C\\u66F4\\u65B0\\u6E32\\u67D3\\u7684\\u5904\\u7406\\u8D70\\u5230\\u6700\\u540E\\u90FD\\u662F\\u8FDB\\u5165\\u4E86\",(0,n.jsx)(e.code,{children:\"scheduleUpdateOnFiber\"})]}),`\n`,(0,n.jsx)(e.h2,{hash:\"\\u6E90\\u7801\\u5206\\u6790\",children:\"\\u6E90\\u7801\\u5206\\u6790\"}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\"scheduleUpdateOnFiber\"}),\" \\u91CD\\u70B9\\u5728\\u4E8E\\u6267\\u884C\\u4E86 \",(0,n.jsx)(e.code,{children:\"ensureRootIsScheduled(root, eventTime);\"})]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-jsx\",children:`// react/packages/react-reconciler/src/ReactFiberWorkLoop.old.js\nexport function scheduleUpdateOnFiber(\n  root: FiberRoot,\n  fiber: Fiber,\n  lane: Lane,\n  eventTime: number,\n) {\n\t\\xB7\\xB7\\xB7\n\n  // Mark that the root has a pending update.\n\t// \\u6807\\u8BB0\\u5F53\\u524D\\u7684 fiber \\u6709 update \\u4EFB\\u52A1\n  markRootUpdated(root, lane, eventTime);\n\n  if (\n    (executionContext & RenderContext) !== NoLanes &&\n    root === workInProgressRoot\n  ) {\n    // This update was dispatched during the render phase. This is a mistake\n    // if the update originates from user space (with the exception of local\n    // hook updates, which are handled differently and don't reach this\n    // function), but there are some internal React features that use this as\n    // an implementation detail, like selective hydration.\n    warnAboutRenderPhaseUpdatesInDEV(fiber);\n\n    // Track lanes that were updated during the render phase\n    workInProgressRootRenderPhaseUpdatedLanes = mergeLanes(\n      workInProgressRootRenderPhaseUpdatedLanes,\n      lane,\n    );\n  } else {\n    // This is a normal update, scheduled from outside the render phase. For\n    // example, during an input event.\n    \\xB7\\xB7\\xB7\n  \n    if (root === workInProgressRoot) {\n      // Received an update to a tree that's in the middle of rendering. Mark\n      // that there was an interleaved update work on this root. Unless the\n      // \\`deferRenderPhaseUpdateToNextBatch\\` flag is off and this is a render\n      // phase update. In that case, we don't treat render phase updates as if\n      // they were interleaved, for backwards compat reasons.\n      if (\n        deferRenderPhaseUpdateToNextBatch ||\n        (executionContext & RenderContext) === NoContext\n      ) {\n        workInProgressRootInterleavedUpdatedLanes = mergeLanes(\n          workInProgressRootInterleavedUpdatedLanes,\n          lane,\n        );\n      }\n      if (workInProgressRootExitStatus === RootSuspendedWithDelay) {\n        // The root already suspended with a delay, which means this render\n        // definitely won't finish. Since we have a new update, let's mark it as\n        // suspended now, right before marking the incoming update. This has the\n        // effect of interrupting the current render and switching to the update.\n        // TODO: Make sure this doesn't override pings that happen while we've\n        // already started rendering.\n        markRootSuspended(root, workInProgressRootRenderLanes);\n      }\n    }\n\n\t\t// \\u91CD\\u70B9\\u5728\\u4E8E\\u8FD9\\u884C\n    ensureRootIsScheduled(root, eventTime);\n    if (\n      lane === SyncLane &&\n      executionContext === NoContext &&\n      (fiber.mode & ConcurrentMode) === NoMode &&\n      // Treat \\`act\\` as if it's inside \\`batchedUpdates\\`, even in legacy mode.\n      !(__DEV__ && ReactCurrentActQueue.isBatchingLegacy)\n    ) {\n      // Flush the synchronous work now, unless we're already working or inside\n      // a batch. This is intentionally inside scheduleUpdateOnFiber instead of\n      // scheduleCallbackForFiber to preserve the ability to schedule a callback\n      // without immediately flushing it. We only do this for user-initiated\n      // updates, to preserve historical behavior of legacy mode.\n      resetRenderTimer();\n      flushSyncCallbacksOnlyInLegacyMode();\n    }\n  }\n}\n`})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-jsx\",children:`export function markRootUpdated(\n  root: FiberRoot,\n  updateLane: Lane,\n  eventTime: number,\n) {\n  root.pendingLanes |= updateLane;\n\n  // If there are any suspended transitions, it's possible this new update\n  // could unblock them. Clear the suspended lanes so that we can try rendering\n  // them again.\n  //\n  // TODO: We really only need to unsuspend only lanes that are in the\n  // \\`subtreeLanes\\` of the updated fiber, or the update lanes of the return\n  // path. This would exclude suspended updates in an unrelated sibling tree,\n  // since there's no way for this update to unblock it.\n  //\n  // We don't do this if the incoming update is idle, because we never process\n  // idle updates until after all the regular updates have finished; there's no\n  // way it could unblock a transition.\n  if (updateLane !== IdleLane) {\n    root.suspendedLanes = NoLanes;\n    root.pingedLanes = NoLanes;\n  }\n\n  const eventTimes = root.eventTimes;\n  const index = laneToIndex(updateLane);\n  // We can always overwrite an existing timestamp because we prefer the most\n  // recent event, and we assume time is monotonically increasing.\n  eventTimes[index] = eventTime;\n}\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\"markRootUpdated\"}),\" \\u53EF\\u4EE5\\u770B\\u5230\\uFF0C\\u5B9E\\u9645\\u662F\\u5728 fiber \\u4FEE\\u6539\\u4E86 \",(0,n.jsx)(e.code,{children:\"root.pendingLanes |= updateLane;\"})]}),`\n`,(0,n.jsxs)(e.p,{children:[\"\\u5E76\\u4E14\\u7531\\u5BF9 \",(0,n.jsx)(e.code,{children:\"lane\"}),\" \\u7684\\u5904\\u7406\\u53EF\\u77E5\\uFF0C\",(0,n.jsx)(e.code,{children:\"fiber.eventTime[laneToIndex(updateLane)] = eventTime\"})]}),`\n`,(0,n.jsxs)(e.p,{children:[\"\\u8FD9\\u91CC\\u521D\\u6B65\\u63A5\\u89E6\\u7684 lane \\u6A21\\u578B\\u7684\\u6982\\u5FF5\\uFF0C\\u5229\\u7528 \",(0,n.jsx)(e.code,{children:\"eventTime\"}),\" \\u6570\\u7EC4\\u6A21\\u62DF\\u4E86\\u4E00\\u4E2A\\u591A\\u8F66\\u9053\\u7684\\u6A21\\u578B\\u3002\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-tsx\",children:`const eventTimes = root.eventTimes;\nconst index = laneToIndex(updateLane);\n// We can always overwrite an existing timestamp because we prefer the most\n// recent event, and we assume time is monotonically increasing.\neventTimes[index] = eventTime;\n`})}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.code,{children:\"ensureRootIsScheduled\"})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-jsx\",children:`// Use this function to schedule a task for a root. There's only one task per\n// root; if a task was already scheduled, we'll check to make sure the priority\n// of the existing task is the same as the priority of the next level that the\n// root has work on. This function is called on every update, and right before\n// exiting a task.\nfunction ensureRootIsScheduled(root: FiberRoot, currentTime: number) {\n\t// \\u6742\\u4E03\\u6742\\u516B\\u4EE3\\u7801\\u6BD4\\u8F83\\u591A\\uFF0C\\u8FD9\\u91CC\\u7B80\\u5316\\u6838\\u5FC3\\u4EE3\\u7801\n\t\\xB7\\xB7\\xB7\n\n\t// Determine the next lanes to work on, and their priority.\n  const nextLanes = getNextLanes(\n    root,\n    root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes,\n  );\n\n\t\\xB7\\xB7\\xB7\n\n\t// We use the highest priority lane to represent the priority of the callback.\n  const newCallbackPriority = getHighestPriorityLane(nextLanes);\n\n\t\\xB7\\xB7\\xB7\n\t// Schedule a new callback.\n  let newCallbackNode;\n  if (newCallbackPriority === SyncLane) {\n\t\t\\xB7\\xB7\\xB7\n\t} else {\n    let schedulerPriorityLevel;\n    switch (lanesToEventPriority(nextLanes)) {\n      case DiscreteEventPriority:\n        schedulerPriorityLevel = ImmediateSchedulerPriority;\n        break;\n      case ContinuousEventPriority:\n        schedulerPriorityLevel = UserBlockingSchedulerPriority;\n        break;\n      case DefaultEventPriority:\n        schedulerPriorityLevel = NormalSchedulerPriority;\n        break;\n      case IdleEventPriority:\n        schedulerPriorityLevel = IdleSchedulerPriority;\n        break;\n      default:\n        schedulerPriorityLevel = NormalSchedulerPriority;\n        break;\n    }\n\t\t// \\u6838\\u5FC3\\u903B\\u8F91\\u662F\\u8D70\\u5230\\u8FD9\\u91CC\n\t\t// \\u8C03\\u7528 scheduleCallback\\uFF0C\\u5C06\\u6E32\\u67D3\\u4EFB\\u52A1\\uFF08\\u5177\\u4F53\\u4E3AperformConcurrentWorkOnRoot\\uFF09\\u4F5C\\u4E3A callback\n\t\t// \\u4F20\\u5165 scheduler \\u7684 API ---- scheduleCallback\\uFF0C\\u91CC\\u9762\\u4F1A\\u521B\\u5EFA task\\uFF0C\\u653E\\u5165 taskQueue \\u7B49\\u5F85\\u8C03\\u5EA6\\u6267\\u884C\n\t\t// \\u4E5F\\u5C31\\u662F\\u6240\\u8C13\\u7684\\u6E32\\u67D3\\u4F1A\\u5728\\u7A7A\\u95F2\\u65F6\\u5019\\u6267\\u884C\n    newCallbackNode = scheduleCallback(\n      schedulerPriorityLevel, // \\u4EFB\\u52A1\\u8C03\\u5EA6\\u7684\\u4F18\\u5148\\u7EA7\n      performConcurrentWorkOnRoot.bind(null, root), // \\u8981\\u6267\\u884C\\u7684\\u4EFB\\u52A1\n    );\n  }\n\n  root.callbackPriority = newCallbackPriority;\n  root.callbackNode = newCallbackNode;\n}\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"\\u81F3\\u6B64\\uFF0C\\u53D1\\u8D77\\u6E32\\u67D3\\u4EFB\\u52A1\\u7684\\u4EE3\\u7801\\uFF08\",(0,n.jsx)(e.code,{children:\"root.render\"}),\" \\u6216 \",(0,n.jsx)(e.code,{children:\"setState\"}),\"\\uFF09\\u6267\\u884C\\u7ED3\\u675F\\uFF0C\\u4EA7\\u751F\\u4E86 \",(0,n.jsx)(e.code,{children:\"performConcurrentWorkOnRoot.bind(null, root),\"}),\" \\u8FD9\\u6837\\u4E00\\u4E2A\\u95ED\\u5305\\u51FD\\u6570\\uFF0C\\u4EA4\\u7ED9\\u4E86 scheduler\\u3002\"]}),`\n`,(0,n.jsx)(e.h2,{hash:\"\\u6838\\u5FC3\\u903B\\u8F91\",children:\"\\u6838\\u5FC3\\u903B\\u8F91\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.code,{children:\"performConcurrentWorkOnRoot\"})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-jsx\",children:`// This is the entry point for every concurrent task, i.e. anything that\n// goes through Scheduler.\nfunction performConcurrentWorkOnRoot(root, didTimeout) {\n  \\xB7\\xB7\\xB7\n\n\t// We disable time-slicing in some cases: if the work has been CPU-bound\n  // for too long (\"expired\" work, to prevent starvation), or we're in\n  // sync-updates-by-default mode.\n  // TODO: We only check \\`didTimeout\\` defensively, to account for a Scheduler\n  // bug we're still investigating. Once the bug in Scheduler is fixed,\n  // we can remove this, since we track expiration ourselves.\n  const shouldTimeSlice =\n    !includesBlockingLane(root, lanes) &&\n    !includesExpiredLane(root, lanes) &&\n    (disableSchedulerTimeoutInWorkLoop || !didTimeout);\n\t// \\u53EA\\u770B\\u6838\\u5FC3\\u4EE3\\u7801\\u884C\n  let exitStatus = shouldTimeSlice\n    ? renderRootConcurrent(root, lanes) // \\u5305\\u542B 18 \\u7684\\u65B0\\u7279\\u6027\n\t\t: renderRootSync(root, lanes); // \\u6CA1\\u6709 concurrent \\u7684\\u5904\\u7406\\u903B\\u8F91\\uFF0C\\u7B80\\u5316\\u7248\\u672C\n\tif (exitStatus !== RootInProgress) {\n\t\t\\xB7\\xB7\\xB7\n\t}\n\n\t\\xB7\\xB7\\xB7\n\n\treturn null;\n}\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"\\u5728\\u521D\\u6B21\\u6E32\\u67D3\\u4E2D\\uFF0C\\u7531\\u4E8E \",(0,n.jsx)(e.code,{children:\"lane\"}),\" \\u662F\\u9ED8\\u8BA4\\u7684 \",(0,n.jsx)(e.code,{children:\"DefaultLane\"}),\"\\uFF0C\",(0,n.jsx)(e.code,{children:\"includesBlockingLane\"}),\" \\u7684\\u7ED3\\u679C\\u4E3A \",(0,n.jsx)(e.code,{children:\"true\"}),\"\\uFF0C\",(0,n.jsx)(e.code,{children:\"shouldTimeSlice\"}),\" \\u503C\\u4E3A \",(0,n.jsx)(e.code,{children:\"false\"}),\"\\uFF0C\\u8D70\\u7684\\u662F \",(0,n.jsx)(e.code,{children:\"renderRootSync\"}),\"\\u3002\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-jsx\",children:`function renderRootSync(root: FiberRoot, lanes: Lanes) {\n  const prevExecutionContext = executionContext;\n  executionContext |= RenderContext; // \\u8FDB\\u5165 render \\u9636\\u6BB5\n  const prevDispatcher = pushDispatcher(root.containerInfo);\n  const prevCacheDispatcher = pushCacheDispatcher();\n\n\t// If the root or lanes have changed, throw out the existing stack\n  // and prepare a fresh one. Otherwise we'll continue where we left off.\n  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\n\t\t\\xB7\\xB7\\xB7\n\t\t// \\u8FD9\\u4E2A\\u51FD\\u6570\\u8C03\\u7528\\u4E86 createWorkInProgress\\uFF0C\\u4EE5 rootfiber \\u4E3A\\u6A21\\u677F\\u590D\\u5236\\u4E00\\u4EFD fiber\n\t\t// \\u5E76\\u8D4B\\u503C\\u7ED9 workInProgress\n\t\tprepareFreshStack(root, lanes);\n  }\n  \\xB7\\xB7\\xB7\n\n\t// \\u6838\\u5FC3\\u5728\\u8FD9\\u91CC\\uFF0C\\u6267\\u884C workLoopSync\n  do {\n    try {\n      workLoopSync();\n      break;\n    } catch (thrownValue) {\n      handleThrow(root, thrownValue);\n    }\n\t\t// todo\\uFF1A\\u6682\\u672A\\u660E\\u767D\\u4E3A\\u4EC0\\u4E48\\u8981 while \\u5FAA\\u73AF\\uFF0C\n\t\t// \\u4ECE\\u4EE3\\u7801\\u6765\\u770B\\u662F workLoopSync \\u5982\\u679C\\u51FA\\u9519\\uFF0C\\u4ECD\\u7136\\u53EF\\u4EE5\\u91CD\\u590D\\u6267\\u884C\\u8FDB\\u884C\\u7EA0\\u9519\\uFF0C\\u4E00\\u65E6\\u6267\\u884C\\u5B8C\\u6BD5\\u5373 break\n\t\t// \\u6240\\u4EE5 renderRootSync \\u662F\\u963B\\u585E\\u7684\n\t\t// \\u800C renderRootConcurrent \\u51FD\\u6570\\u4F1A\\u901A\\u8FC7\\u5224\\u65AD workInProgressSuspendedThenableState \\u963B\\u6B62\\u963B\\u585E\n  } while (true); \n  resetContextDependencies();\n\n\t\\xB7\\xB7\\xB7\n\treturn workInProgressRootExitStatus;\n}\n`})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-jsx\",children:`// The work loop is an extremely hot path. Tell Closure not to inline it.\n/** @noinline */\nfunction workLoopSync() {\n  // Perform work without checking if we need to yield between fiber.\n\n  if (workInProgressIsSuspended) {\n    // The current work-in-progress was already attempted. We need to unwind\n    // it before we continue the normal work loop.\n\t\t// react \\u6E90\\u7801\\u5176\\u5B9E\\u8FD8\\u662F\\u4F1A\\u6EE5\\u7528\\u5168\\u5C40\\u53D8\\u91CF\\u7684...\n    const thrownValue = workInProgressThrownValue;\n    workInProgressIsSuspended = false;\n    workInProgressThrownValue = null;\n    if (workInProgress !== null) {\n\t\t\t// \\u5982\\u679C\\u53D1\\u73B0\\u4E4B\\u524D\\u5904\\u7406\\u7684\\u4EFB\\u52A1\\u88AB\\u4E2D\\u65AD\\u4E86\\uFF0C\\u90A3\\u4E48\\u5219\\u4F1A\\u6062\\u590D\\u73B0\\u573A\\uFF0C\\u7EE7\\u7EED\\u6267\\u884C\n      resumeSuspendedUnitOfWork(workInProgress, thrownValue);\n    }\n  }\n\n  while (workInProgress !== null) {\n\t\t// \\u8FDB\\u5165\\u5230 workLoopSync\\uFF0C\\u6838\\u5FC3\\u903B\\u8F91\\u5C31\\u662F\\u904D\\u5386 fiber \\u6811\n    performUnitOfWork(workInProgress);\n  }\n}\n`})}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-jsx\",children:`// react/packages/react-reconciler/src/ReactFiberWorkLoop.old.js\n\nfunction performUnitOfWork(unitOfWork: Fiber): void {\n  // The current, flushed, state of this fiber is the alternate. Ideally\n  // nothing should rely on this, but relying on it here means that we don't\n  // need an additional field on the work in progress.\n  const current = unitOfWork.alternate;\n  setCurrentDebugFiberInDEV(unitOfWork);\n\n  let next;\n  console.log('workInProgress',workInProgress)\n  if (enableProfilerTimer && (unitOfWork.mode & ProfileMode) !== NoMode) {\n    startProfilerTimer(unitOfWork);\n    next = beginWork(current, unitOfWork, renderLanes);\n    stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);\n  } else {\n\t\t// \\u8D70\\u8FD9\\u91CC\n    next = beginWork(current, unitOfWork, renderLanes);\n  }\n  console.log('next',next)\n  resetCurrentDebugFiberInDEV();\n  unitOfWork.memoizedProps = unitOfWork.pendingProps;\n  if (next === null) {\n    // If this doesn't spawn new work, complete the current work.\n    completeUnitOfWork(unitOfWork);\n  } else {\n    workInProgress = next;\n  }\n\n  ReactCurrentOwner.current = null;\n}\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"\\u53C2\\u6570 \",(0,n.jsx)(e.code,{children:\"unitOfWork\"}),\" \\u4E3A \",(0,n.jsx)(e.code,{children:\"workInProgress\"})]}),`\n`,(0,n.jsx)(e.p,{children:\"\\u9996\\u6B21\\u6E32\\u67D3\\u60C5\\u51B5\\u4E0B\\uFF0C\\u5982\\u679C\\u6E32\\u67D3\\u4EE5\\u4E0B\\u9875\\u9762\\uFF1A\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-jsx\",children:`const jsx = (\n  <div className=\"box border\" style={{ color: \"red\", lineHeight: \"20px\" }}>\n    <h2>ooo</h2>\n  </div>\n);\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"\\u6253\\u5370\\u7ED3\\u679C\\uFF1A\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-tsx\",children:`workInProgress FiberNode\\xA0{tag: 3, key: null, elementType: null, type: null, stateNode: FiberRootNode,\\xA0\\u2026}\nnext FiberNode\\xA0{tag: 5, key: null, elementType: 'div', type: 'div', stateNode: null,\\xA0\\u2026}\nworkInProgress FiberNode\\xA0{tag: 5, key: null, elementType: 'div', type: 'div', stateNode: null,\\xA0\\u2026}\nnext FiberNode\\xA0{tag: 5, key: null, elementType: 'h2', type: 'h2', stateNode: null,\\xA0\\u2026}\nworkInProgress FiberNode\\xA0{tag: 5, key: null, elementType: 'h2', type: 'h2', stateNode: null,\\xA0\\u2026}\nnext null\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"\\u6839\\u636E\\u6253\\u5370\\u7ED3\\u679C\\u53EF\\u4EE5\\u5F97\\u5230\\uFF0C\",(0,n.jsx)(e.code,{children:\"workLoopSync\"}),\" \\u7684 \",(0,n.jsx)(e.code,{children:\"while\"}),\" \\u5FAA\\u73AF\\u4E2D\\u7684 \",(0,n.jsx)(e.code,{children:\"performUnitOfWork\"}),\" \\u6267\\u884C\\u4E86\\u4E09\\u6B21\\uFF1A\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-tsx\",children:`//1 FiberRootNode\nnext = beginWork(current, unitOfWork, renderLanes);\nworkInProgress = next;\n\n// 2\nnext = beginWork(current, unitOfWork, renderLanes);\nworkInProgress = next;\n\n// 3\nnext = beginWork(current, unitOfWork, renderLanes);\ncompleteUnitOfWork(unitOfWork);\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\"beginWork\"}),\" \\u51FD\\u6570\\u7528\\u4E8E\\u6267\\u884C\\u7EC4\\u4EF6\\u7684\\u66F4\\u65B0\\u64CD\\u4F5C\\uFF1B\\u63A5\\u6536\\u4E24\\u4E2A\\u53C2\\u6570\\uFF1A\\u5F53\\u524D\\u7684 \",(0,n.jsx)(e.code,{children:\"fiber\"}),\" \\u8282\\u70B9\\uFF08\",(0,n.jsx)(e.code,{children:\"current\"}),\"\\uFF09\\u548C\\u5F85\\u66F4\\u65B0\\u7684 \",(0,n.jsx)(e.code,{children:\"fiber\"}),\" \\u8282\\u70B9\\uFF08\",(0,n.jsx)(e.code,{children:\"workInProgress\"}),\"\\uFF09\\u3002\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"\\u8C03\\u7528 \",(0,n.jsx)(e.code,{children:\"reconcileChildren\"}),\" \\u51FD\\u6570\\u6765\\u5904\\u7406\\u5B50\\u7EC4\\u4EF6\\u7684\\u66F4\\u65B0\\uFF0C\\u7136\\u540E\\u8FD4\\u56DE\\u4E00\\u4E2A\\u65B0\\u7684 fiber \\u8282\\u70B9\\uFF0C\\u8FD9\\u4E2A\\u65B0\\u8282\\u70B9\\u5305\\u542B\\u4E86\\u66F4\\u65B0\\u540E\\u7684\\u7EC4\\u4EF6\\u5B9E\\u4F8B\\u548C\\u5C5E\\u6027\\u3002\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-jsx\",children:`function beginWork(\n  current: Fiber | null, // rootFiber\n  workInProgress: Fiber, // \\u5F53\\u524D\\u5904\\u7406\\u7684 fiber\n  renderLanes: Lanes,\n): Fiber | null {\n  \\xB7\\xB7\\xB7\n\n  // current \\u6307\\u5411 alternate\\uFF0C\\u4E0D\\u4E3A null \\u5219\\u8868\\u793A\\u4E0D\\u662F\\u9996\\u6B21\\u6E32\\u67D3\n  if (current !== null) {\n    const oldProps = current.memoizedProps;\n    const newProps = workInProgress.pendingProps;\n\n    if (\n      oldProps !== newProps ||\n      hasLegacyContextChanged() ||\n      // Force a re-render if the implementation changed due to hot reload:\n      (__DEV__ ? workInProgress.type !== current.type : false)\n    ) {\n      // If props or context changed, mark the fiber as having performed work.\n      // This may be unset if the props are determined to be equal later (memo).\n      didReceiveUpdate = true;\n    } else {\n      // Neither props nor legacy context changes. Check if there's a pending\n      // update or context change.\n      const hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(\n        current,\n        renderLanes,\n      );\n      if (\n        !hasScheduledUpdateOrContext &&\n        // If this is the second pass of an error or suspense boundary, there\n        // may not be work scheduled on \\`current\\`, so we check for this flag.\n        (workInProgress.flags & DidCapture) === NoFlags\n      ) {\n        // No pending updates or context. Bail out now.\n        didReceiveUpdate = false;\n        return attemptEarlyBailoutIfNoScheduledUpdate(\n          current,\n          workInProgress,\n          renderLanes,\n        );\n      }\n      if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags) {\n        // This is a special case that only exists for legacy mode.\n        // See https://github.com/facebook/react/pull/19216.\n        didReceiveUpdate = true;\n      } else {\n        // An update was scheduled on this fiber, but there are no new props\n        // nor legacy context. Set this to false. If an update queue or context\n        // consumer produces a changed value, it will set this to true. Otherwise,\n        // the component will assume the children have not changed and bail out.\n        didReceiveUpdate = false;\n      }\n    }\n  } else {\n\t\t// \\u9996\\u6B21\\u6E32\\u67D3\n\t\t// \\u8FD9\\u4E2A\\u53D8\\u91CF\\u53EF\\u4EE5\\u6682\\u65F6\\u4E0D\\u7406\\u4F1A\n    didReceiveUpdate = false;\n\n\t  \\xB7\\xB7\\xB7\n  }\n\n  // Before entering the begin phase, clear pending update priority.\n  // TODO: This assumes that we're about to evaluate the component and process\n  // the update queue. However, there's an exception: SimpleMemoComponent\n  // sometimes bails out later in the begin phase. This indicates that we should\n  // move this assignment out of the common path and into each branch.\n  workInProgress.lanes = NoLanes;\n\t// \\u6839\\u636E\\u5F53\\u524D fiber \\u7684\\u7C7B\\u578B\\u5BF9\\u7EC4\\u4EF6\\u8FDB\\u884C\\u5904\\u7406\n  switch (workInProgress.tag) {\n    \\xB7\\xB7\\xB7\n    case FunctionComponent: {\n      const Component = workInProgress.type;\n      const unresolvedProps = workInProgress.pendingProps;\n      const resolvedProps =\n        workInProgress.elementType === Component\n          ? unresolvedProps\n          : resolveDefaultProps(Component, unresolvedProps);\n      return updateFunctionComponent(\n        current,\n        workInProgress,\n        Component,\n        resolvedProps,\n        renderLanes,\n      );\n    }\n    case ClassComponent: {\n      const Component = workInProgress.type;\n      const unresolvedProps = workInProgress.pendingProps;\n      const resolvedProps =\n        workInProgress.elementType === Component\n          ? unresolvedProps\n          : resolveDefaultProps(Component, unresolvedProps);\n      return updateClassComponent(\n        current,\n        workInProgress,\n        Component,\n        resolvedProps,\n        renderLanes,\n      );\n    }\n\t  \\xB7\\xB7\\xB7\n  }\n\n  throw new Error(\n    \\`Unknown unit of work tag (\\${workInProgress.tag}). This error is likely caused by a bug in \\` +\n      'React. Please file an issue.',\n  );\n}\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\"completeUnitOfWork\"}),\" \\u51FD\\u6570\\u7528\\u4E8E\\u5B8C\\u6210\\u4E00\\u4E2A\\u7EC4\\u4EF6\\u7684\\u904D\\u5386\\u3002\\u5728\\u51FD\\u6570\\u5185\\u90E8\\uFF0C\\u4F1A\\u5148\\u68C0\\u67E5 \",(0,n.jsx)(e.code,{children:\"workInProgress\"}),\" \\u662F\\u5426\\u4E3A \",(0,n.jsx)(e.code,{children:\"null\"}),\"\\uFF0C\\u5982\\u679C\\u662F\\uFF0C\\u90A3\\u4E48\\u8BF4\\u660E\\u8FD9\\u4E2A\\u7EC4\\u4EF6\\u5DF2\\u7ECF\\u5B8C\\u6210\\u4E86\\u6240\\u6709\\u7684\\u66F4\\u65B0\\u64CD\\u4F5C\\u3002\"]}),`\n`,(0,n.jsx)(e.p,{children:\"Todo\\uFF1A\\u7EE7\\u7EED\\u6DF1\\u6316\\u903B\\u8F91\"})]})}function y(r={}){let{wrapper:e}=r.components||{};return e?(0,n.jsx)(e,Object.assign({},r,{children:(0,n.jsx)(c,r)})):c(r)}var P=y;return b(x);})();\n;return Component;"},"__N_SSG":true}