{"pageProps":{"toc":[{"text":"Scheduler","hash":"#scheduler","depth":1},{"text":"重点关注","hash":"#重点关注","depth":3},{"text":"任务调度","hash":"#任务调度","depth":2},{"text":"最小堆","hash":"#最小堆","depth":3},{"text":"任务产生","hash":"#任务产生","depth":3},{"text":"任务调度执行","hash":"#任务调度执行","depth":3},{"text":"任务调度为什么选择宏任务","hash":"#任务调度为什么选择宏任务","depth":2},{"text":"让渡主线程","hash":"#让渡主线程","depth":3}],"code":"var Component=(()=>{var u=Object.create;var l=Object.defineProperty;var h=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var k=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),g=(t,e)=>{for(var i in e)l(t,i,{get:e[i],enumerable:!0})},o=(t,e,i,a)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let r of p(e))!f.call(t,r)&&r!==i&&l(t,r,{get:()=>e[r],enumerable:!(a=h(e,r))||a.enumerable});return t};var T=(t,e,i)=>(i=t!=null?u(m(t)):{},o(e||!t||!t.__esModule?l(i,\"default\",{value:t,enumerable:!0}):i,t)),b=t=>o(l({},\"__esModule\",{value:!0}),t);var c=k((P,s)=>{s.exports=_jsx_runtime});var x={};g(x,{default:()=>I});var n=T(c());function d(t){let e=Object.assign({h1:\"h1\",p:\"p\",h3:\"h3\",ul:\"ul\",li:\"li\",h2:\"h2\",code:\"code\",strong:\"strong\",pre:\"pre\",ol:\"ol\",a:\"a\"},t.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.h1,{hash:\"scheduler\",children:\"Scheduler\"}),`\n`,(0,n.jsx)(e.p,{children:\"scheduler \\u662F\\u4E00\\u79CD\\u5728\\u6D4F\\u89C8\\u5668\\u8C03\\u5EA6\\u5904\\u7406\\u4EFB\\u52A1\\u7684\\u6027\\u80FD\\u4F18\\u5316\\u65B9\\u6848\\u7684\\u5B9E\\u73B0\\u3002\\u4EFB\\u52A1\\u4F1A\\u88AB\\u5B58\\u5165\\u6700\\u5C0F\\u5806\\u4E2D\\u7B49\\u5F85\\u8C03\\u5EA6\\u6267\\u884C\\uFF1B\\u4EFB\\u52A1\\u5728\\u6267\\u884C\\u65F6\\u53EF\\u4EE5\\u88AB\\u4E2D\\u6B62\\uFF08\\u8BA9\\u6E21\\u4E3B\\u7EBF\\u7A0B\\u53BB\\u5904\\u7406\\u5176\\u4ED6\\u4E8B\\u60C5\\uFF09\\uFF0C\\u800C\\u540E\\u7EE7\\u7EED\\u6267\\u884C\\u3002\"}),`\n`,(0,n.jsx)(e.p,{children:\"\\u5728 react \\u4E2D scheduler \\u88AB\\u7528\\u6765\\u8C03\\u5EA6\\u6267\\u884C\\u7EC4\\u4EF6\\u6E32\\u67D3\\u7684\\u4EFB\\u52A1\\uFF0C\\u4ECE\\u800C\\u5B9E\\u73B0\\u4E0D\\u963B\\u585E\\u9875\\u9762\\u7684\\u7528\\u6237\\u54CD\\u5E94\\u3002\\u8BE5\\u6A21\\u5757\\u7684\\u4EE3\\u7801\\u5B8C\\u5168\\u72EC\\u7ACB\\u4E8E\\u5176\\u4ED6\\u5176\\u4ED6\\u6A21\\u5757\\uFF0C\\u5982\\u540C\\u4E00\\u4E2A\\u7B2C\\u4E09\\u65B9\\u5E93\\u88AB react \\u8C03\\u7528\\u3002\"}),`\n`,(0,n.jsx)(e.h3,{hash:\"\\u91CD\\u70B9\\u5173\\u6CE8\",children:\"\\u91CD\\u70B9\\u5173\\u6CE8\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"react \\u6E32\\u67D3\\u4EFB\\u52A1\\u5982\\u4F55\\u4F20\\u5165 scheduler \\u88AB\\u5B58\\u50A8\\u7684\\uFF1F\\u6700\\u5C0F\\u5806\\u5B58\\u653E task\"}),`\n`,(0,n.jsx)(e.li,{children:\"\\u4EFB\\u52A1\\u5728\\u54EA\\u4E2A\\u51FD\\u6570\\u88AB\\u6267\\u884C\\uFF0C\\u4F9D\\u6B21\\u6267\\u884C\\u7684\\u987A\\u5E8F\\uFF1F\"}),`\n`,(0,n.jsx)(e.li,{children:\"\\u6267\\u884C\\u4EFB\\u52A1\\u8BA9\\u6E21\\u4E3B\\u7EBF\\u7A0B\\u7684\\u5177\\u4F53\\u4EE3\\u7801\\u903B\\u8F91\\u662F\\u4EC0\\u4E48\\uFF1FshouldYieldToHost\"}),`\n`,(0,n.jsx)(e.li,{children:\"\\u4EFB\\u52A1\\u6267\\u884C\\u7684\\u4E2D\\u65AD\\u548C\\u6062\\u590D\"}),`\n`,(0,n.jsx)(e.li,{children:\"\\u4EFB\\u52A1\\u4F18\\u5148\\u7EA7\\u53C2\\u4E0E\\u7684\\u4EE3\\u7801\\u903B\\u8F91\"}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{hash:\"\\u4EFB\\u52A1\\u8C03\\u5EA6\",children:\"\\u4EFB\\u52A1\\u8C03\\u5EA6\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"scheduler \\u5C31\\u662F\\u505A\\u4EFB\\u52A1\\u8C03\\u5EA6\\u8FD9\\u4EF6\\u4E8B\\uFF0C\\u5728 react \\u4E2D\\uFF0C\",(0,n.jsx)(e.code,{children:\"createRoot\"}),\"\\uFF0C\",(0,n.jsx)(e.code,{children:\"setState\"}),\"\\uFF0C\",(0,n.jsx)(e.code,{children:\"context\"}),\" \\u7B49 API \\u4F1A\\u4EA7\\u751F\\u6E32\\u67D3\\u4EFB\\u52A1\\uFF0C\\u5E76\\u4E14\\u6E32\\u67D3\\u4EFB\\u52A1\\u4F1A\\u6709\\u4F18\\u5148\\u7EA7\\uFF0C\\u53EF\\u4EE5\\u88AB\\u4E2D\\u65AD\\u6267\\u884C\\u3002\"]}),`\n`,(0,n.jsx)(e.h3,{hash:\"\\u6700\\u5C0F\\u5806\",children:\"\\u6700\\u5C0F\\u5806\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"\\u624B\\u52A8\\u5B9E\\u73B0\\u4E00\\u4E2A\\u7B80\\u5355\\u7684\\u6700\\u5C0F\\u5806\\uFF0C\\u6700\\u5C0F\\u5806\\u662F\",(0,n.jsx)(e.strong,{children:\"\\u4E00\\u79CD\\u7ECF\\u8FC7\\u6392\\u5E8F\\u7684\\u5B8C\\u5168\\u4E8C\\u53C9\\u6811\\uFF0C\\u5176\\u4E2D\\u4EFB\\u4E00\\u975E\\u7EC8\\u7AEF\\u8282\\u70B9\\u7684\\u6570\\u636E\\u503C\\u5747\\u4E0D\\u5927\\u4E8E\\u5176\\u5DE6\\u5B50\\u8282\\u70B9\\u548C\\u53F3\\u5B50\\u8282\\u70B9\\u7684\\u503C\"}),\"\\u3002\"]}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"peek\"}),\"\\uFF1A\\u83B7\\u53D6\\u5806\\u9876\\u5143\\u7D20\\uFF0C\\u5373\\u6240\\u6709\\u5143\\u7D20\\u7684\\u6700\\u5C0F\\u503C\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"pop\"}),\"\\uFF1A\\u5F39\\u51FA\\u5806\\u9876\\u5143\\u7D20\\uFF0C\\u4F1A\\u91CD\\u65B0\\u6392\\u5E8F\\u6784\\u5EFA\\u6700\\u5C0F\\u5806\\u7ED3\\u6784\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"push\"}),\"\\uFF1A\\u63D2\\u5165\\u5143\\u7D20\\uFF0C\\u4F1A\\u91CD\\u65B0\\u6392\\u5E8F\\u6784\\u5EFA\\u6700\\u5C0F\\u5806\\u7ED3\\u6784\"]}),`\n`]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`export function peek(heap) {\n  return heap.length === 0 ? null : heap[0];\n}\n\nexport function push(heap, node) {\n  let index = heap.length;\n  heap.push(node);\n  siftUp(heap, node, index);\n}\n\n// \\u5148\\u653E\\u5728\\u5C3E\\u90E8\\uFF0C\\u5411\\u4E0A\\u67E5\\u627E\nfunction siftUp(heap, node, i) {\n  let index = i;\n  while (index > 0) {\n    const parentIndex = (index - 1) >> 1;\n    const parent = heap[parentIndex];\n    if (compare(parent, node) > 0) {\n      heap[parentIndex] = node;\n      heap[index] = parent;\n      index = parentIndex;\n    } else {\n      return;\n    }\n  }\n}\n\nexport function pop(heap) {\n  if (heap.length === 0) {\n    return null;\n  }\n\n  const first = heap[0];\n  const last = heap.pop();\n\n  if (first !== last) {\n    heap[0] = last;\n    siftDown(heap, last, 0);\n  }\n  return first;\n}\n\n// \\u5F39\\u51FA\\u9996\\u5143\\u7D20\\uFF0C\\u5206\\u522B\\u5BF9\\u5DE6\\u53F3\\u8FDB\\u884C\\u6BD4\\u8F83\nfunction siftDown(heap, node, i) {\n  let index = i;\n  const len = heap.length;\n  const halfLen = len >> 1;\n  while (index < halfLen) {\n    const leftIndex = (index + 1) * 2 - 1;\n    const rightIndex = leftIndex + 1;\n    const left = heap[leftIndex];\n    const right = heap[rightIndex];\n    if (compare(left, node) < 0) {\n      if (rightIndex < len && compare(right, left) < 0) {\n        heap[index] = right;\n        heap[rightIndex] = node;\n        index = rightIndex;\n      } else {\n        // not right or right < left\n        heap[index] = left;\n        heap[leftIndex] = node;\n        index = leftIndex;\n      }\n    } else if (rightIndex < len && compare(right, node) < 0) {\n      heap[index] = right;\n      heap[rightIndex] = node;\n      index = rightIndex;\n    } else {\n      return;\n    }\n  }\n}\n\nfunction compare(a, b) {\n  // return a - b;\n  const diff = a.sortIndex - b.sortIndex;\n  return diff !== 0 ? diff : a.id - b.id;\n}\n`})}),`\n`,(0,n.jsx)(e.h3,{hash:\"\\u4EFB\\u52A1\\u4EA7\\u751F\",children:\"\\u4EFB\\u52A1\\u4EA7\\u751F\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"react \\u4E2D\\u8C03\\u7528\\u4E86 \",(0,n.jsx)(e.code,{children:\"Scheduler.unstable_scheduleCallback\"}),\" \\uFF0C\\u901A\\u8FC7\\u8FD9\\u4E2A\\u51FD\\u6570\\u5C06\\u6E32\\u67D3\\u4EFB\\u52A1\\u5B58\\u50A8 \",(0,n.jsx)(e.code,{children:\"taskQueue\"}),\" \\u4E2D\\uFF0C\",(0,n.jsx)(e.code,{children:\"taskQueue\"}),\" \\u662F\\u6700\\u5C0F\\u5806\\u7C7B\\u578B\\uFF0C\\u5B58\\u653E\\u4EFB\\u52A1\\u7B49\\u5F85\\u8C03\\u5EA6\\u6267\\u884C\\u3002\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`// react/packages/scheduler/src/forks/Scheduler.js\nfunction unstable_scheduleCallback(\n  priorityLevel: PriorityLevel,\n  callback: Callback,\n  options?: {delay: number},\n): Task {\n\t// \\u5F53\\u524D\\u65F6\\u95F4\\u6233\n  var currentTime = getCurrentTime();\n\n  var startTime;\n\t// react \\u6CA1\\u7528\\u5230 option\n  if (typeof options === 'object' && options !== null) {\n    var delay = options.delay;\n    if (typeof delay === 'number' && delay > 0) {\n      startTime = currentTime + delay;\n    } else {\n      startTime = currentTime;\n    }\n  } else {\n\t\t// \\u8BBE\\u7F6E\\u5F00\\u59CB\\u65F6\\u95F4\n    startTime = currentTime;\n  }\n\n\t// \\u6839\\u636E\\u4F18\\u5148\\u7EA7\\u8BBE\\u7F6E\\u8D85\\u65F6\\u65F6\\u95F4\n  var timeout;\n  switch (priorityLevel) {\n    case ImmediatePriority: // \\u6700\\u9AD8\\u4F18\\u5148\\u7EA7\\uFF0C\\u8D85\\u65F6\\u65F6\\u95F4\\u6700\\u77ED\n      timeout = IMMEDIATE_PRIORITY_TIMEOUT;\n      break;\n    case UserBlockingPriority:\n      timeout = USER_BLOCKING_PRIORITY_TIMEOUT;\n      break;\n    case IdlePriority:\n      timeout = IDLE_PRIORITY_TIMEOUT;\n      break;\n    case LowPriority:\n      timeout = LOW_PRIORITY_TIMEOUT;\n      break;\n    case NormalPriority:\n    default:\n      timeout = NORMAL_PRIORITY_TIMEOUT;\n      break;\n  }\n\t// \\u6839\\u636E\\u4EFB\\u52A1\\u4F18\\u5148\\u7EA7\\u8BBE\\u7F6E\\u8FC7\\u671F\\u65F6\\u95F4\n  var expirationTime = startTime + timeout;\n\n\t// \\u4EFB\\u52A1\\u521B\\u5EFA\\uFF0C\\u8BB2\\u672C\\u51FD\\u6570\\u53C2\\u6570 callback \\u88AB\\u5B58\\u5165\\u4EFB\\u52A1\\u4E2D\n  var newTask: Task = {\n    id: taskIdCounter++,\n    callback,\n    priorityLevel,\n    startTime,\n    expirationTime,\n    sortIndex: -1,\n  };\n  if (enableProfiling) {\n    newTask.isQueued = false;\n  }\n\n  if (startTime > currentTime) {\n\t\t// \\u8FD9\\u91CC\\u662F\\u6709 option \\u7684\\u60C5\\u51B5\\uFF0Creact \\u6CA1\\u6709\\u7528\\u5230\n    // This is a delayed task.\n    newTask.sortIndex = startTime;\n    push(timerQueue, newTask);\n    if (peek(taskQueue) === null && newTask === peek(timerQueue)) {\n      // All tasks are delayed, and this is the task with the earliest delay.\n      if (isHostTimeoutScheduled) {\n        // Cancel an existing timeout.\n        cancelHostTimeout();\n      } else {\n        isHostTimeoutScheduled = true;\n      }\n      // Schedule a timeout.\n      requestHostTimeout(handleTimeout, startTime - currentTime);\n    }\n  } else {\n\t\t// \\u6CA1\\u6709 option \\u7684\\u60C5\\u51B5\\u8D70\\u8FD9\\u91CC\n\t\t// sortIndex \\u4E3A task \\u88AB push \\u5230\\u6700\\u5C0F\\u5806\\u65F6\\u7684\\u6392\\u5E8F index\\uFF0C\n\t\t// \\u4E0D\\u96BE\\u7406\\u89E3\\uFF0C\\u4EFB\\u52A1\\u8FC7\\u671F\\u65F6\\u95F4\\u8D8A\\u5C0F\\uFF0C\\u8D8A\\u9760\\u8FD1\\u5806\\u9876\\uFF0C\\u8D8A\\u4F18\\u5148\\u5904\\u7406\n    newTask.sortIndex = expirationTime;\n    push(taskQueue, newTask);\n    if (enableProfiling) {\n      markTaskStart(newTask, currentTime);\n      newTask.isQueued = true;\n    }\n    // Schedule a host callback, if needed. If we're already performing work,\n    // wait until the next time we yield.\n\t\t// isHostCallbackScheduled \\u610F\\u601D\\u662F\\u662F\\u5426\\u6709 host callback \\u4EFB\\u52A1\\u88AB\\u8C03\\u5EA6\\u4E86\n    if (!isHostCallbackScheduled && !isPerformingWork) {\n      isHostCallbackScheduled = true;\n      requestHostCallback(flushWork);\n    }\n  }\n\n  return newTask;\n}\n`})}),`\n`,(0,n.jsx)(e.h3,{hash:\"\\u4EFB\\u52A1\\u8C03\\u5EA6\\u6267\\u884C\",children:\"\\u4EFB\\u52A1\\u8C03\\u5EA6\\u6267\\u884C\"}),`\n`,(0,n.jsx)(e.p,{children:\"scheduler \\u662F\\u5C06\\u4F20\\u5165\\u7684\\u4EFB\\u52A1\\u653E\\u5230\\u5B8F\\u4EFB\\u52A1\\u7684\\u4E8B\\u4EF6\\u5FAA\\u73AF\\u91CC\\u6267\\u884C\\u3002\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"\\u4F9D\\u6B21\\u6709\\u4E09\\u79CD\\u517C\\u5BB9\\u6027\\u964D\\u7EA7\\u7684\\u65B9\\u6848\\uFF1A\",(0,n.jsx)(e.code,{children:\"setImmediate\"}),\" \\u2192 \",(0,n.jsx)(e.code,{children:\"MessageChannel\"}),\" \\u2192\",(0,n.jsx)(e.code,{children:\"SetTimeout\"})]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`// react/packages/scheduler/src/forks/Scheduler.js\nlet schedulePerformWorkUntilDeadline;\nif (typeof localSetImmediate === 'function') {\n  // Node.js and old IE.\n  // There's a few reasons for why we prefer setImmediate.\n  //\n  // Unlike MessageChannel, it doesn't prevent a Node.js process from exiting.\n  // (Even though this is a DOM fork of the Scheduler, you could get here\n  // with a mix of Node.js 15+, which has a MessageChannel, and jsdom.)\n  // https://github.com/facebook/react/issues/20756\n  //\n  // But also, it runs earlier which is the semantic we want.\n  // If other browsers ever implement it, it's better to use it.\n  // Although both of these would be inferior to native scheduling.\n  schedulePerformWorkUntilDeadline = () => {\n    localSetImmediate(performWorkUntilDeadline);\n  };\n} else if (typeof MessageChannel !== 'undefined') {\n  // DOM and Worker environments.\n  // We prefer MessageChannel because of the 4ms setTimeout clamping.\n  const channel = new MessageChannel();\n  const port = channel.port2;\n  channel.port1.onmessage = performWorkUntilDeadline;\n  schedulePerformWorkUntilDeadline = () => {\n    port.postMessage(null);\n  };\n} else {\n  // We should only fallback here in non-browser environments.\n  schedulePerformWorkUntilDeadline = () => {\n    // $FlowFixMe[not-a-function] nullable value\n    localSetTimeout(performWorkUntilDeadline, 0);\n  };\n}\n`})}),`\n`,(0,n.jsx)(e.p,{children:\"\\u5B9E\\u9645\\u6267\\u884C\\u7684\\u5C31\\u662F\\uFF1A\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`let schedulePerformWorkUntilDeadline;\nschedulePerformWorkUntilDeadline = () => {\n   localSetImmediate(performWorkUntilDeadline);\n};\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"\\u518D\\u56DE\\u5230\\u4ECE \",(0,n.jsx)(e.code,{children:\"scheduleUpdateOnFiber\"}),\" \\u5230 task \\u88AB\\u6267\\u884C\\uFF1A\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`// \\u7B80\\u8981\\u4EE3\\u7801\\u6267\\u884C\\u6D41\\u7A0B\nfunction unstable_scheduleCallback () {\n\trequestHostCallback(flushWork);\n}\nfunction requestHostCallback(callback) {\n  scheduledHostCallback = callback;\n  if (!isMessageLoopRunning) {\n    isMessageLoopRunning = true;\n\t\t// \\u6267\\u884C\\u4E0A\\u4E00\\u6BB5\\u4EE3\\u7801\\u7684  localSetImmediate(performWorkUntilDeadline);\n    schedulePerformWorkUntilDeadline();\n  }\n}\n// \\u91CC\\u9762\\u7684 scheduledHostCallback \\u4E3A flushWork\nconst performWorkUntilDeadline = () => {\n  if (scheduledHostCallback !== null) {\n    const currentTime = getCurrentTime();\n    // Keep track of the start time so we can measure how long the main thread\n    // has been blocked.\n    startTime = currentTime;\n\n    // If a scheduler task throws, exit the current browser task so the\n    // error can be observed.\n    //\n    // Intentionally not using a try-catch, since that makes some debugging\n    // techniques harder. Instead, if \\`scheduledHostCallback\\` errors, then\n    // \\`hasMoreWork\\` will remain true, and we'll continue the work loop.\n    let hasMoreWork = true;\n    try {\n      // $FlowFixMe[not-a-function] found when upgrading Flow\n      hasMoreWork = scheduledHostCallback(currentTime);\n    } finally {\n      if (hasMoreWork) {\n        // If there's more work, schedule the next message event at the end\n        // of the preceding one.\n        schedulePerformWorkUntilDeadline();\n      } else {\n        isMessageLoopRunning = false;\n        scheduledHostCallback = null;\n      }\n    }\n  } else {\n    isMessageLoopRunning = false;\n  }\n  // Yielding to the browser will give it a chance to paint, so we can\n  // reset this.\n  needsPaint = false;\n};\n\nfunction flushWork(initialTime: number) {\n  if (enableProfiling) {\n\t  \\xB7\\xB7\\xB7\n  }\n\n  // We'll need a host callback the next time work is scheduled.\n  isHostCallbackScheduled = false;\n  if (isHostTimeoutScheduled) {\n    // We scheduled a timeout but it's no longer needed. Cancel it.\n    isHostTimeoutScheduled = false;\n    cancelHostTimeout();\n  }\n\n  isPerformingWork = true;\n  const previousPriorityLevel = currentPriorityLevel;\n  try {\n    if (enableProfiling) {\n\t    \\xB7\\xB7\\xB7\n    } else {\n      // No catch in prod code path.\n      return workLoop(initialTime);\n    }\n  } finally {\n    currentTask = null;\n    currentPriorityLevel = previousPriorityLevel;\n    isPerformingWork = false;\n    if (enableProfiling) {\n     \\xB7\\xB7\\xB7\n    }\n  }\n}\n\nfunction workLoop(initialTime: number) {function workLoop(initialTime: number) {\n  let currentTime = initialTime;\n  advanceTimers(currentTime);\n\t// \\u53D6 task\n  currentTask = peek(taskQueue);\n  while (\n    currentTask !== null &&\n    !(enableSchedulerDebugging && isSchedulerPaused)\n  ) {\n    if (currentTask.expirationTime > currentTime && shouldYieldToHost()) {\n      // This currentTask hasn't expired, and we've reached the deadline.\n      break;\n    }\n    // $FlowFixMe[incompatible-use] found when upgrading Flow\n    const callback = currentTask.callback;\n    if (typeof callback === 'function') {\n      // $FlowFixMe[incompatible-use] found when upgrading Flow\n      currentTask.callback = null;\n      // $FlowFixMe[incompatible-use] found when upgrading Flow\n      currentPriorityLevel = currentTask.priorityLevel;\n      // $FlowFixMe[incompatible-use] found when upgrading Flow\n      const didUserCallbackTimeout = currentTask.expirationTime <= currentTime;\n      if (enableProfiling) {\n        // $FlowFixMe[incompatible-call] found when upgrading Flow\n        markTaskRun(currentTask, currentTime);\n      }\n      const continuationCallback = callback(didUserCallbackTimeout);\n      currentTime = getCurrentTime();\n      if (typeof continuationCallback === 'function') {\n        // If a continuation is returned, immediately yield to the main thread\n        // regardless of how much time is left in the current time slice.\n        // $FlowFixMe[incompatible-use] found when upgrading Flow\n        currentTask.callback = continuationCallback;\n        if (enableProfiling) {\n          \\xB7\\xB7\\xB7\n        }\n        advanceTimers(currentTime);\n        return true;\n      } else {\n        if (enableProfiling) {\n          \\xB7\\xB7\\xB7\n        }\n        if (currentTask === peek(taskQueue)) {\n          pop(taskQueue);\n        }\n        advanceTimers(currentTime);\n      }\n    } else {\n      pop(taskQueue);\n    }\n    currentTask = peek(taskQueue);\n  }\n  // Return whether there's additional work\n  if (currentTask !== null) {\n    return true;\n  } else {\n    const firstTimer = peek(timerQueue);\n    if (firstTimer !== null) {\n      requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n    }\n    return false;\n  }\n}\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"\\u53EF\\u4EE5\\u770B\\u51FA\\uFF0C\\u6838\\u5FC3\\u6267\\u884C\\u6D41\\u7A0B\\u662F\\u901A\\u8FC7 \",(0,n.jsx)(e.code,{children:\"while\"}),\" \\u5FAA\\u73AF\\u4E0D\\u65AD\\u53D6 \",(0,n.jsx)(e.code,{children:\"taskQueue\"}),\" \\u4E2D\\u7684 \",(0,n.jsx)(e.code,{children:\"task\"}),\"\\uFF0C\\u5E76\\u6267\\u884C\\u5176 \",(0,n.jsx)(e.code,{children:\"task.callback\"})]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`// \\u7B80\\u5316\\u7248\\u6D41\\u7A0B\nfunction workLoop(initialTime: number) {\n\t\\xB7\\xB7\\xB7  \n\t// \\u83B7\\u53D6\\u5806\\u9876\\u4EFB\\u52A1\n\tcurrentTask = peek(taskQueue);\n  while (\n    currentTask !== null &&\n    !(enableSchedulerDebugging && isSchedulerPaused)\n  ) {\n\t\t// \\u524D\\u4E00\\u4E2A\\u6BD4\\u8F83\\u662F\\u4E00\\u4E2A\\u8D2A\\u5FC3\\u7684\\u7B56\\u7565\\uFF0C\\u672A\\u5230 deadline\\uFF0C\\u53EF\\u4EE5\\u518D\\u7B49\\u7B49\n\t\t// \\u5982\\u679C\\u662F\\u4F18\\u5148\\u7EA7\\u8F83\\u9AD8\\u7684\\uFF0C\\u90A3\\u5176\\u5B9E\\u4F1A\\u5F88\\u5FEB\\u8FC7\\u671F\n\t\t// shouldYieldToHost \\u662F\\u4E2D\\u65AD\\u7684\\u903B\\u8F91\n\t\tif (currentTask.expirationTime > currentTime && shouldYieldToHost()) {\n      // This currentTask hasn't expired, and we've reached the deadline.\n      break;\n    }\n\t\t// \\u6267\\u884C callback\n\t\tconst callback = currentTask.callback;\n    if (typeof callback === 'function') {\n\t\t\tconst continuationCallback = callback(didUserCallbackTimeout);\n      if (typeof continuationCallback === 'function') {\n\t\t\t\tcurrentTask.callback = continuationCallback;\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tif (currentTask === peek(taskQueue)) {\n          pop(taskQueue);\n        }\n\t\t\t}\n\t\t} else {\n\t\t\t// \\u79FB\\u9664\\u88AB\\u6267\\u884C\\u7684\\u4EFB\\u52A1\n      pop(taskQueue);\n    }\n\t\t// \\u83B7\\u53D6\\u4E0B\\u4E00\\u4E2A\\u5806\\u9876\\u4EFB\\u52A1\n\t\tcurrentTask = peek(taskQueue);\n\t}\n}\n`})}),`\n`,(0,n.jsxs)(e.p,{children:[\"\\u51FD\\u6570\\u4E2D\\u8C03\\u7528 \",(0,n.jsx)(e.code,{children:\"shouldYieldToHost\"}),\" \\u5224\\u65AD\\u662F\\u5426\\u8BA9\\u6E21\\u5904\\u7406\\u6743\\u7ED9\\u9875\\u9762\\uFF0C\\u5B9E\\u9645\\u6548\\u679C\\u5C31\\u662F\\u63D0\\u524D\\u7ED3\\u675F\\u6389\\u5F53\\u524D\\u8FD9\\u4E2A\\u5B8F\\u4EFB\\u52A1\\uFF0C\\u5F53\\u524D\\u4EFB\\u52A1\\u7684\\u540E\\u7EED\\u5185\\u5BB9\\u88AB\\u4E2D\\u65AD\\uFF0C\\u4E0D\\u6267\\u884C\\u4E86\\u3002\\u91CC\\u9762\\u903B\\u8F91\\u6BD4\\u8F83\\u590D\\u6742\\uFF0C\\u65F6\\u95F4\\u5224\\u65AD\\u903B\\u8F91\\u8F83\\u591A\\uFF0C\\u540E\\u7EED\\u518D\\u7814\\u7A76\\u3002\\u4F46\\u662F\\u91CD\\u70B9\\u662F\\u8C03\\u7528\\u4E86 \",(0,n.jsx)(e.code,{children:\"navigator.scheduling.isInputPending\"}),\" \\uFF0C\\u8FD9\\u4E2A API \\u7684\\u517C\\u5BB9\\u6027\\u4E0D\\u592A\\u884C\\uFF0C\\u662F react \\u548C chrome \\u5408\\u4F5C\\u641E\\u51FA\\u6765\\u7684\\u3002\\u5982\\u679C\\u6D4F\\u89C8\\u5668\\u4EFB\\u52A1\\u961F\\u5217\\u4E2D\\u6709\\u8F93\\u5165\\u4E8B\\u4EF6\\u5F85\\u5904\\u7406\\uFF0C\\u5219\\u8FD4\\u56DE \",(0,n.jsx)(e.code,{children:\"true\"}),\"\\u3002\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`// \\u6709\\u5174\\u8DA3\\u770B\\u770B\\u5C31\\u884C\nconst isInputPending =\n  typeof navigator !== 'undefined' &&\n  // $FlowFixMe[prop-missing]\n  navigator.scheduling !== undefined &&\n  // $FlowFixMe[incompatible-type]\n  navigator.scheduling.isInputPending !== undefined\n    ? navigator.scheduling.isInputPending.bind(navigator.scheduling)\n    : null;\n\nfunction shouldYieldToHost(): boolean {\n  const timeElapsed = getCurrentTime() - startTime;\n  if (timeElapsed < frameInterval) {\n    // The main thread has only been blocked for a really short amount of time;\n    // smaller than a single frame. Don't yield yet.\n    return false;\n  }\n\n  if (enableIsInputPending) {\n    if (needsPaint) {\n      // There's a pending paint (signaled by \\`requestPaint\\`). Yield now.\n      return true;\n    }\n    if (timeElapsed < continuousInputInterval) {\n      // We haven't blocked the thread for that long. Only yield if there's a\n      // pending discrete input (e.g. click). It's OK if there's pending\n      // continuous input (e.g. mouseover).\n      if (isInputPending !== null) {\n        return isInputPending();\n      }\n    } else if (timeElapsed < maxInterval) {\n      // Yield if there's either a pending discrete or continuous input.\n      if (isInputPending !== null) {\n        return isInputPending(x);\n      }\n    } else {\n      // We've blocked the thread for a long time. Even if there's no pending\n      // input, there may be some other scheduled work that we don't know about,\n      // like a network event. Yield now.\n      return true;\n    }\n  }\n\n  // \\`isInputPending\\` isn't available. Yield now.\n  return true;\n}\n`})}),`\n`,(0,n.jsx)(e.h2,{hash:\"\\u4EFB\\u52A1\\u8C03\\u5EA6\\u4E3A\\u4EC0\\u4E48\\u9009\\u62E9\\u5B8F\\u4EFB\\u52A1\",children:\"\\u4EFB\\u52A1\\u8C03\\u5EA6\\u4E3A\\u4EC0\\u4E48\\u9009\\u62E9\\u5B8F\\u4EFB\\u52A1\"}),`\n`,(0,n.jsxs)(e.p,{children:[\"\\u5F53\\xA0\",(0,n.jsx)(e.code,{children:\"shouldYieldToHost()\"}),\"\\xA0\\u8FD4\\u56DE\\xA0\",(0,n.jsx)(e.code,{children:\"true\"}),\"\\xA0\\u540E\\uFF0CScheduler \\u9700\\u8981\\u6EE1\\u8DB3\\u4EE5\\u4E0B\\u529F\\u80FD\\u70B9\\uFF1A\"]}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsx)(e.li,{children:\"\\u6682\\u505C\\u6E32\\u67D3\\u4EFB\\u52A1\\u7684\\u6267\\u884C\\uFF0C\\u5C06\\u4E3B\\u7EBF\\u7A0B\\u8FD8\\u7ED9\\u6D4F\\u89C8\\u5668\\uFF0C\\u8BA9\\u6D4F\\u89C8\\u5668\\u6709\\u673A\\u4F1A\\u66F4\\u65B0\\u9875\\u9762\\u53BB\\u5904\\u7406\\u7528\\u6237\\u54CD\\u5E94\\u7B49\\u4EFB\\u52A1\"}),`\n`,(0,n.jsxs)(e.li,{children:[\"\\u5728\\u672A\\u6765\\u67D0\\u4E2A\\u65F6\\u523B\\u7EE7\\u7EED\\u8C03\\u5EA6\\u4EFB\\u52A1\\uFF0C\\u6267\\u884C\\u4E0A\\u6B21\\u8FD8\\u6CA1\\u6709\\u5B8C\\u6210\\u7684\\u4EFB\\u52A1\\uFF08\\u8FD9\\u90E8\\u5206\\u903B\\u8F91\\u4E0D\\u5728 scheduler\\uFF0C\\u81F3\\u4E8E\\u5982\\u4F55\\u4FDD\\u7559\\u5F53\\u524D\\u73B0\\u573A\\uFF0C\\u4E4B\\u540E\\u6062\\u590D\\u73B0\\u573A\\u5E76\\u7EE7\\u7EED\\u6267\\u884C\\uFF0C\\u662F\\u4EFB\\u52A1\\u91CC\\u7684 callback \\u5E94\\u8BE5\\u505A\\u7684\\u4E8B\\uFF0C\\u5B9E\\u9645\\u4E0A\\uFF0C\\u6E32\\u67D3\\u4EFB\\u52A1\\u7684 callback \\u91CC\\u4E5F\\u4F1A\\u7528\\u5230 \",(0,n.jsx)(e.code,{children:\"shouldYieldToHost\"}),\" \\uFF09\"]}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"\\u8981\\u6EE1\\u8DB3\\u8FD9\\u4E24\\u70B9\\u5C31\\u9700\\u8981\\u8C03\\u5EA6\\u4E00\\u4E2A\\u5B8F\\u4EFB\\u52A1\\uFF0C\\u56E0\\u4E3A\\u5B8F\\u4EFB\\u52A1\\u662F\\u5728\\u4E0B\\u6B21\\u4E8B\\u4EF6\\u5FAA\\u73AF\\u4E2D\\u6267\\u884C\\uFF0C\\u4E0D\\u4F1A\\u963B\\u585E\\u672C\\u6B21\\u9875\\u9762\\u66F4\\u65B0\\u3002\"}),`\n`,(0,n.jsx)(\"img\",{src:\"/lifeOfAFrame.png\",width:800,height:300}),`\n`,(0,n.jsxs)(e.p,{children:[\"\\u4E3A\\u4EC0\\u4E48\\u4E0D\\u7528\\u5FAE\\u4EFB\\u52A1\\uFF0C\",(0,n.jsx)(e.code,{children:\"requestAnimationFrame\"}),\" \\u6216 \",(0,n.jsx)(e.code,{children:\"requestIdleCallback\"}),\"?\"]}),`\n`,(0,n.jsxs)(e.p,{children:[`\\u5FAE\\u4EFB\\u52A1\\u662F\\u5728\\u672C\\u6B21\\u4E8B\\u4EF6\\u5FAA\\u73AF\\u91CC\\u6267\\u884C\\uFF0C\\u5982\\u679C\\u4EA7\\u751F\\u7684\\u6E32\\u67D3\\u4EFB\\u52A1\\u662F\\u4EE5\\u5FAE\\u4EFB\\u52A1\\u65B9\\u5F0F\\u6267\\u884C\\uFF0C\\u90A3\\u4E48\\u5FC5\\u987B\\u4EA7\\u751F\\u7684\\u5FAE\\u4EFB\\u52A1\\u90FD\\u6267\\u884C\\u5B8C\\u6BD5\\u624D\\u8FDB\\u5165\\u4E0B\\u4E00\\u4E2A\\u5B8F\\u4EFB\\u52A1\\u3002\nraf \\u4E0D\\u5C5E\\u4E8E\\u5FAE\\u4EFB\\u52A1\\u6216\\u5B8F\\u4EFB\\u52A1\\uFF0C\\u662F\\u5728\\u5E27\\u95F4\\u6267\\u884C\\u4E00\\u6B21\\uFF0C\\u800C\\u5B8F\\u4EFB\\u52A1\\u5728\\u5E27\\u95F4\\u4E0D\\u4E00\\u5B9A\\u53EA\\u6267\\u884C\\u4E00\\u4E2A\\uFF0C\\u53EF\\u4EE5\\u6267\\u884C\\u591A\\u4E2A\\u6700\\u540E\\u518D\\u4E00\\u8D77\\u6E32\\u67D3\\u3002\\u5177\\u4F53\\u53EF\\u4EE5\\u770B\\u8FD9\\u4E2A\\u5206\\u6790 `,(0,n.jsx)(e.a,{href:\"https://juejin.cn/post/7165780929439334437\",children:\"React \\u4E4B requestAnimationFrame \\u6267\\u884C\\u673A\\u5236\\u63A2\\u7D22\"}),`\n`,(0,n.jsx)(e.code,{children:\"requestIdleCallback\"}),\" \\u662F\\u517C\\u5BB9\\u6027\\u8F83\\u5DEE\\u4E0D\\u9002\\u5408\\u5728\\u751F\\u4EA7\\u73AF\\u5883\\u4E0A\\uFF0C\\u5E76\\u4E14\\u5B83\\u5B9E\\u9645\\u4E0A\\u662F\\u5728\\u5E03\\u5C40\\u548C\\u7ED8\\u5236\\u4E4B\\u540E\\u6267\\u884C\\uFF0C\\u90A3\\u610F\\u5473\\u5728\\u91CC\\u9762\\u505A\\u7684\\u4E8B\\u60C5\\uFF08\\u53EF\\u80FD\\u662F\\u901A\\u8FC7\\u6570\\u636E\\u4FEE\\u6539\\u89E6\\u53D1dom\\u4FEE\\u6539\\uFF09\\u4F1A\\u91CD\\u6392\\u3002\"]}),`\n`,(0,n.jsx)(e.h3,{hash:\"\\u8BA9\\u6E21\\u4E3B\\u7EBF\\u7A0B\",children:\"\\u8BA9\\u6E21\\u4E3B\\u7EBF\\u7A0B\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.code,{children:\"shouldYieldToHost\"})}),`\n`,(0,n.jsxs)(e.p,{children:[(0,n.jsx)(e.code,{children:\"navigator.scheduling.isInputPending API\"}),\"\\u662F react \\u4E0E Chrome \\u56E2\\u961F\\u5408\\u4F5C\\u7684\\u4EA7\\u7269\\u3002\"]}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-js\",children:`function shouldYieldToHost(): boolean {\n  const timeElapsed = getCurrentTime() - startTime;\n  if (timeElapsed < frameInterval) {\n    // The main thread has only been blocked for a really short amount of time;\n    // smaller than a single frame. Don't yield yet.\n    return false;\n  }\n\n  // The main thread has been blocked for a non-negligible amount of time. We\n  // may want to yield control of the main thread, so the browser can perform\n  // high priority tasks. The main ones are painting and user input. If there's\n  // a pending paint or a pending input, then we should yield. But if there's\n  // neither, then we can yield less often while remaining responsive. We'll\n  // eventually yield regardless, since there could be a pending paint that\n  // wasn't accompanied by a call to \\`requestPaint\\`, or other main thread tasks\n  // like network events.\n  if (enableIsInputPending) {\n    if (needsPaint) {\n      // There's a pending paint (signaled by \\`requestPaint\\`). Yield now.\n      return true;\n    }\n    if (timeElapsed < continuousInputInterval) {\n      // We haven't blocked the thread for that long. Only yield if there's a\n      // pending discrete input (e.g. click). It's OK if there's pending\n      // continuous input (e.g. mouseover).\n      if (isInputPending !== null) {\n        return isInputPending();\n      }\n    } else if (timeElapsed < maxInterval) {\n      // Yield if there's either a pending discrete or continuous input.\n      if (isInputPending !== null) {\n        return isInputPending(continuousOptions);\n      }\n    } else {\n      // We've blocked the thread for a long time. Even if there's no pending\n      // input, there may be some other scheduled work that we don't know about,\n      // like a network event. Yield now.\n      return true;\n    }\n  }\n\n  // \\`isInputPending\\` isn't available. Yield now.\n  return true;\n}\n`})})]})}function w(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,Object.assign({},t,{children:(0,n.jsx)(d,t)})):d(t)}var I=w;return b(x);})();\n;return Component;"},"__N_SSG":true}